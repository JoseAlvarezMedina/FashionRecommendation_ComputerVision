# -*- coding: utf-8 -*-
"""Recommendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VWpJmvuSQ805fXuy6YfsFibrd7Em1K1R
"""

import numpy as np
import pandas as pd
import os
import tensorflow as tf
import tensorflow.keras as keras
import pathlib
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import cv2
from tensorflow.keras.applications import EfficientNetB1
from tensorflow.keras.models import Sequential, Model
from tensorflow.keras.layers import Input, GlobalAveragePooling2D, BatchNormalization, Dense
from sklearn.model_selection import train_test_split
from keras.preprocessing import image
from keras.applications.densenet import preprocess_input, decode_predictions
from keras.layers import GlobalMaxPooling2D
from tensorflow.keras.utils import plot_model
import os
import numpy as np
import pandas as pd
from tensorflow.keras.preprocessing.image import load_img, img_to_array
from tensorflow.keras.applications.efficientnet import EfficientNetB1, preprocess_input
import kagglehub

"""#Importamos de kaggle las imagenes"""

# Descarga el dataset ligero desde Kaggle
dataset_path = kagglehub.dataset_download("paramaggarwal/fashion-product-images-small")
print("Dataset descargado en:", dataset_path)

# Definir ruta de imágenes
image_folder = os.path.join(dataset_path, "images")  # Ajustar según la estructura del dataset

# Mostrar algunas imágenes de ejemplo
plt.figure(figsize=(12, 6))
for i, img_name in enumerate(os.listdir(image_folder)[:10]):  # Tomar las primeras 10 imágenes
    img_path = os.path.join(image_folder, img_name)
    img = mpimg.imread(img_path)
    plt.subplot(2, 5, i+1)
    plt.imshow(img)
    plt.axis("off")
    height, width, _ = img.shape
    plt.title(f'{width}x{height}', fontsize=10)
    plt.axis('off')  # Optional: remove axes for clarity
plt.show()

"""Creamos el dataframe"""

# Definir la nueva ruta base (descargada con kagglehub)
dataset_path = kagglehub.dataset_download("paramaggarwal/fashion-product-images-small")

# Ruta del archivo styles.csv
csv_path = os.path.join(dataset_path, "styles.csv")

# Leer el CSV (tomando solo 6000 filas y evitando errores en líneas defectuosas)
styles_df = pd.read_csv(csv_path, nrows=6000, on_bad_lines='skip')

# Crear una columna 'image' con el nombre de archivo correspondiente (id.jpg)
styles_df['image'] = styles_df['id'].astype(str) + ".jpg"

# Mostrar información del DataFrame
print("Shape del DataFrame:", styles_df.shape)
styles_df.head(5)

img_width, img_height, chnls = 100, 100, 3

"""Preprocesamiento de imagenes"""

def preprocess_image(image_path, target_size):
    img = load_img(image_path, target_size=target_size)
    img_array = img_to_array(img)
    img_array = img_array / 255.0  # Normalizar la imagen
    return img_array

# Ruta de la carpeta de imágenes
image_folder = os.path.join(dataset_path, "images")  # Ajustar si la carpeta tiene otro nombre

# Obtener la lista de archivos de imagen
image_files = [os.path.join(image_folder, f) for f in os.listdir(image_folder) if f.endswith('.jpg')]

# Mostrar algunas imágenes encontradas
print(f"Total de imágenes encontradas: {len(image_files)}")
print("Ejemplo de imágenes:", image_files[:5])  # Mostrar 5 ejemplos

"""#uso de EfficientBetB1"""

efficient_net_model_1 = EfficientNetB1(include_top=False, input_shape=(img_width, img_height, chnls))
# Añadir una capa de agrupamiento global promedio para reducir la dimensionalidad
x = efficient_net_model_1.output
x = GlobalAveragePooling2D()(x)


# Definir el modelo completo que retornará el vector de características
vectorization_model_1 = Model(inputs=efficient_net_model_1.input, outputs=x)

vectorization_model_1.summary()

dataset_path = kagglehub.dataset_download("paramaggarwal/fashion-product-images-small")
image_folder = os.path.join(dataset_path, "images")  # Ajustar si la carpeta tiene otro nombre

# Función para obtener la ruta de la imagen
def img_path(img):
    """ Toma el nombre del archivo de imagen (id.jpg) y devuelve su ruta completa """
    return os.path.join(image_folder, img)

# Función para predecir con el modelo
def predict(model, img_name):
    """ Carga y preprocesa la imagen, luego realiza una predicción con el modelo """

    # Cargar la imagen y cambiar su tamaño
    img = load_img(img_path(img_name), target_size=(img_width, img_height))

    # Convertir la imagen en un array
    img = img_to_array(img)

    # Expandir las dimensiones para que sea compatible con la entrada del modelo
    img = np.expand_dims(img, axis=0)

    # Preprocesar la imagen según el modelo
    img = preprocess_input(img)

    # Hacer la predicción
    return model.predict(img)

sample_img = predict(vectorization_model_1, "10037.jpg")
print(sample_img)
sample_img.shape

"""Ya vectorizamos con EfficientNetB1, ahora vectorizaremos todas las imagenes"""

# import os
# import numpy as np

# # Descargar el dataset ligero desde Kaggle
# dataset_path = kagglehub.dataset_download("paramaggarwal/fashion-product-images-small")

# # Ruta de la carpeta de imágenes
# image_folder = os.path.join(dataset_path, "images")

# # Obtener la lista de archivos de imagen
# image_files = [os.path.join(image_folder, f) for f in os.listdir(image_folder) if f.endswith('.jpg')]

# # Lista para almacenar los vectores de características
# features_list = []

# # Procesar cada imagen
# for img_route in image_files:
#     print(img_route)  # Ruta completa de la imagen
#     img_name = os.path.basename(img_route)  # Nombre del archivo
#     print(img_name)

#     # Obtener la ruta completa de la imagen (ya está en image_files, por lo que esto es redundante)
#     img_path_full = img_route
#     print(img_path_full)

#     # Extraer características con el modelo de vectorización
#     features = predict(vectorization_model_1, img_name)

#     # Agregar las características a la lista
#     features_list.append(features)

# # Convertir la lista de características a un array numpy
# features_array = np.vstack(features_list)

# # Verificar la forma del array resultante
# print("Forma del array de características:", features_array.shape)

import pickle

# Cargar la lista desde el archivo
with open('features_list_efficientnetb1.pkl', 'rb') as f:
    features_array_c = pickle.load(f)

# Imprimir la lista cargada
print(len(features_array_c))

!pip install annoy

import annoy
from annoy import AnnoyIndex

num_features = features_array_c.shape[1]

# Número de dimensiones de los vectores de características
num_features = features_array_c.shape[1]

# Crear un índice Annoy utilizando la métrica Euclidean (distancia euclidiana)
annoy_index_dot = AnnoyIndex(num_features, 'dot')

# Agregar vectores de características al índice Annoy
for i, feature_vector in enumerate(features_array_c):
    annoy_index_dot.add_item(i, feature_vector)

# Construir el índice Annoy
annoy_index_dot.build(n_trees=10)

# Consultar el índice Annoy para encontrar imágenes similares a una imagen de consulta
query_image_index = 99 # Índice de la imagen de consulta en features_array
num_neighbors = 25  # Número de imágenes similares a recuperar

# Utilizar el índice Annoy para encontrar imágenes similares
similar_image_indices_dot = annoy_index_dot.get_nns_by_item(query_image_index, num_neighbors)

# Imprimir los índices de las imágenes similares
print("Índices de imágenes similares (dot):", similar_image_indices_dot)

import os
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

# Descargar el dataset ligero desde Kaggle si aún no se ha hecho
dataset_path = kagglehub.dataset_download("paramaggarwal/fashion-product-images-small")

# Ruta de la carpeta de imágenes
image_folder = os.path.join(dataset_path, "images")

# Obtener la lista de archivos de imagen
image_files = sorted([f for f in os.listdir(image_folder) if f.endswith('.jpg')])  # Ordenado por nombre

# Función para obtener el nombre del archivo de imagen a partir del índice
def get_image_file(index):
    return os.path.join(image_folder, image_files[index])  # Retorna la ruta completa

# Simulación: Lista de índices de imágenes similares obtenidas de Annoy
# Asegúrate de que `similar_image_indices_dot` esté definido antes de ejecutar esto
similar_image_indices = similar_image_indices_dot

# Crear una figura para mostrar las imágenes
plt.figure(figsize=(20, 20))

# Graficar la imagen de consulta en la posición central (3, 3) de una cuadrícula 5x5
for i, img_index in enumerate(similar_image_indices):
    plt.subplot(5, 5, i + 1)  # Crear una cuadrícula de 5x5
    img_file = get_image_file(img_index)
    img = mpimg.imread(img_file)

    if img_index == query_image_index:  # Imagen de consulta
        plt.imshow(img, cmap='gray')
        plt.title(f'Query Index: {img_index}', fontsize=14, color='red')
        plt.gca().add_patch(plt.Rectangle((0, 0), img.shape[1], img.shape[0], linewidth=5, edgecolor='red', facecolor='none'))
    else:  # Imágenes similares
        plt.imshow(img)
        plt.title(f'Index: {img_index}', fontsize=12)

    plt.axis('off')  # Opcional: eliminar los ejes para mayor claridad

plt.subplots_adjust(wspace=0.1, hspace=0.1)
plt.show()

